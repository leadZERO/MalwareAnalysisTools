// Copyright (c) 2017 Ryan Sommers <ryans@rpsommers.com>
// All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
LittleEndian();

void
ReadWStr(int64 pos, wchar_t buf[], int n)
{
	local int i = 0;
	for (i = 0; i < n; ++i)
		buf[i] = ReadUShort(pos + i*sizeof(wchar_t));
}


struct IMAGE_DOS_HEADER {  	// DOS .EXE header
	WORD   e_magic; 	// Magic number
	WORD   e_cblp;  	// Bytes on last page of file
	WORD   e_cp;		// Pages in file
	WORD   e_crlc;  	// Relocations
	WORD   e_cparhdr;   // Size of header in paragraphs
	WORD   e_minalloc;  // Minimum extra paragraphs needed
	WORD   e_maxalloc;  // Maximum extra paragraphs needed
	WORD   e_ss;		// Initial (relative) SS value
	WORD   e_sp;		// Initial SP value
	WORD   e_csum;  	// Checksum
	WORD   e_ip;		// Initial IP value
	WORD   e_cs;		// Initial (relative) CS value
	WORD   e_lfarlc;	// File address of relocation table
	WORD   e_ovno;  	// Overlay number
	WORD   e_res[4];	// Reserved words
	WORD   e_oemid; 	// OEM identifier (for e_oeminfo)
	WORD   e_oeminfo;   // OEM information; e_oemid specific
	WORD   e_res2[10];  // Reserved words
	LONG   e_lfanew;	// File address of new exe header
};

/*======================================== */

IMAGE_DOS_HEADER dosHeader <bgcolor=cLtRed>;

if (dosHeader.e_magic != 0x5a4d)
	Warning("Not a .EXE file!");

if (dosHeader.e_lfanew > FileSize())
	Warning("Bad PE pointer");

FSeek(dosHeader.e_lfanew);

/*======================================== */

enum <ushort> MACHINE_TYPE
{
	 IMAGE_FILE_MACHINE_UNKNOWN =   	0,
	 IMAGE_FILE_MACHINE_I386	=  	 	0x014c,  // Intel 386.
	 IMAGE_FILE_MACHINE_R3000 	= 		0x0162,  // MIPS little-endian, 0x160 big-endian
	 IMAGE_FILE_MACHINE_R4000 	=		0x0166,  // MIPS little-endian
	 IMAGE_FILE_MACHINE_R10000  =   	0x0168,  // MIPS little-endian
	 IMAGE_FILE_MACHINE_WCEMIPSV2 = 	0x0169,  // MIPS little-endian WCE v2
	 IMAGE_FILE_MACHINE_ALPHA  	=		0x0184,  // Alpha_AXP
	 IMAGE_FILE_MACHINE_SH3  	=  		0x01a2,  // SH3 little-endian
	 IMAGE_FILE_MACHINE_SH3DSP	= 		0x01a3,
	 IMAGE_FILE_MACHINE_SH3E   	=		0x01a4,  // SH3E little-endian
	 IMAGE_FILE_MACHINE_SH4 	=   	0x01a6,  // SH4 little-endian
	 IMAGE_FILE_MACHINE_SH5  	=  		0x01a8,  // SH5
	 IMAGE_FILE_MACHINE_ARM   	= 		0x01c0,  // ARM Little-Endian
	 IMAGE_FILE_MACHINE_THUMB  	=		0x01c2,
	 IMAGE_FILE_MACHINE_AM33	=   	0x01d3,
	 IMAGE_FILE_MACHINE_POWERPC =  		0x01F0,  // IBM PowerPC Little-Endian
	 IMAGE_FILE_MACHINE_POWERPCFP =		0x01f1,
	 IMAGE_FILE_MACHINE_IA64	=  		0x0200,  // Intel 64
	 IMAGE_FILE_MACHINE_MIPS16  =	  	0x0266,  // MIPS
	 IMAGE_FILE_MACHINE_ALPHA64	=		0x0284,  // ALPHA64
	 IMAGE_FILE_MACHINE_MIPSFPU = 	 	0x0366,  // MIPS
	 IMAGE_FILE_MACHINE_MIPSFPU16 =		0x0466,  // MIPS
	 IMAGE_FILE_MACHINE_AXP64	=  		0x0284,
	 IMAGE_FILE_MACHINE_TRICORE = 	 	0x0520,  // Infineon
	 IMAGE_FILE_MACHINE_CEF		=		0x0CEF,
	 IMAGE_FILE_MACHINE_EBC  	= 	 	0x0EBC,  // EFI Byte Code
	 IMAGE_FILE_MACHINE_AMD64	=		0x8664,  // AMD64 (K8)
	 IMAGE_FILE_MACHINE_M32R 	=		0x9041,  // M32R little-endian
	 IMAGE_FILE_MACHINE_CEE  	=	 	0xC0EE
};

enum IMAGE_FILE_HEADER_CHARACTERISTICS_enum
{
	IMAGE_FILE_RELOCS_STRIPPED           = 0x0001,  // Relocation info stripped from file.
	IMAGE_FILE_EXECUTABLE_IMAGE          = 0x0002,  // File is executable  (i.e. no unresolved externel references).
	IMAGE_FILE_LINE_NUMS_STRIPPED        = 0x0004,  // Line nunbers stripped from file.
	IMAGE_FILE_LOCAL_SYMS_STRIPPED       = 0x0008,  // Local symbols stripped from file.
	IMAGE_FILE_AGGRESIVE_WS_TRIM         = 0x0010,  // Agressively trim working set
	IMAGE_FILE_LARGE_ADDRESS_AWARE       = 0x0020,  // App can handle >2gb addresses
	IMAGE_FILE_BYTES_REVERSED_LO         = 0x0080,  // Bytes of machine word are reversed.
	IMAGE_FILE_32BIT_MACHINE             = 0x0100,  // 32 bit word machine.
	IMAGE_FILE_DEBUG_STRIPPED            = 0x0200,  // Debugging info stripped from file in .DBG file
	IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   = 0x0400,  // If Image is on removable media, copy and run from the swap file.
	IMAGE_FILE_NET_RUN_FROM_SWAP         = 0x0800,  // If Image is on Net, copy and run from the swap file.
	IMAGE_FILE_SYSTEM                    = 0x1000,  // System File.
	IMAGE_FILE_DLL                       = 0x2000,  // File is a DLL.
	IMAGE_FILE_UP_SYSTEM_ONLY            = 0x4000,  // File should only be run on a UP machine
	IMAGE_FILE_BYTES_REVERSED_HI         = 0x8000  // Bytes of machine word are reversed.
};

typedef struct {
	union {
		struct {
			WORD bIMAGE_FILE_RELOCS_STRIPPED : 1;
			WORD bIMAGE_FILE_EXECUTABLE_IMAGE : 1;
			WORD bIMAGE_FILE_LINE_NUMS_STRIPPED : 1;
			WORD bIMAGE_FILE_LOCAL_SYMS_STRIPPED : 1;
			WORD bIMAGE_FILE_AGGRESIVE_WS_TRIM : 1;
			WORD bIMAGE_FILE_LARGE_ADDRESS_AWARE : 1;
			WORD bUnused : 1;
			WORD bIMAGE_FILE_BYTES_REVERSED_LO : 1;
			WORD bIMAGE_FILE_32BIT_MACHINE : 1;
			WORD bIMAGE_FILE_DEBUG_STRIPPED : 1;
			WORD bIMAGE_FILE_REMOVABLE_RUN_FROM_SWAP : 1;
			WORD bIMAGE_FILE_NET_RUN_FROM_SWAP : 1;
			WORD bIMAGE_FILE_SYSTEM : 1;
			WORD bIMAGE_FILE_DLL : 1;
			WORD bIMAGE_FILE_UP_SYSTEM_ONLY : 1;
			WORD bIMAGE_FILE_BYTES_REVERSED_HI : 1;
		} BITMASK;
		WORD Characteristics;
	} U;	
} IMAGE_FILE_HEADER_CHARACTERISTICS;

typedef struct {
	MACHINE_TYPE Machine;
	WORD	NumberOfSections;
	time_t 	TimeDateStamp;
	DWORD	PointerToSymbolTable;
	DWORD	NumberOfSymbols;
	WORD	SizeOfOptionalHeader;
	IMAGE_FILE_HEADER_CHARACTERISTICS Characteristics;
} IMAGE_FILE_HEADER;

/*======================================== */

char peSig[4];

if (peSig != "PE\0\0")
	Warning("PE signature mismatch");

IMAGE_FILE_HEADER fileHeader <bgcolor=cLtYellow>;

/*======================================== */

typedef struct {
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY <read=ReadImageDataDirectory>;

string
ReadImageDataDirectory(IMAGE_DATA_DIRECTORY &h)
{
    char buf[128];
    SPrintf(buf, "<VirtAddr=%X, Size=%X>", h.VirtualAddress, h.Size);
    return buf;
}

enum <short> IMAGE_SUBSYSTEM {
	IMAGE_SUBSYSTEM_UNKNOWN		= 0,   // Unknown subsystem.
	IMAGE_SUBSYSTEM_NATIVE		= 1,   // Image doesn't require a subsystem.
	IMAGE_SUBSYSTEM_WINDOWS_GUI	= 2,   // Image runs in the Windows GUI subsystem.
	IMAGE_SUBSYSTEM_WINDOWS_CUI	= 3,   // Image runs in the Windows character subsystem.
	IMAGE_SUBSYSTEM_OS2_CUI		= 5,   // image runs in the OS/ 2 character subsystem.
	IMAGE_SUBSYSTEM_POSIX_CUI	= 7,   // image runs in the Posix character subsystem.
	IMAGE_SUBSYSTEM_NATIVE_WINDOWS	= 8,   // image is a native Win9x driver.
	IMAGE_SUBSYSTEM_WINDOWS_CE_GUI	= 9,   // Image runs in the Windows CE subsystem.
	IMAGE_SUBSYSTEM_EFI_APPLICATION = 10,  //
	IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER	= 11,   //
	IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER		= 12,   //
	IMAGE_SUBSYSTEM_EFI_ROM			= 13,
	IMAGE_SUBSYSTEM_XBOX			= 14,
	IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16
};

enum IMAGE_DLLCHARACTERISTICS_enum {
	IMAGE_LIBRARY_PROCESS_INIT			= 0x0001,		// Reserved.
	IMAGE_LIBRARY_PROCESS_TERM			= 0x0002,		// Reserved.
	IMAGE_LIBRARY_THREAD_INIT			= 0x0004,		// Reserved.
	IMAGE_LIBRARY_THREAD_TERM			= 0x0008,		// Reserved.
	IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 	 = 0x0040,	// DLL can move.
	IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = 0x0080,	// Code Integrity Image
	IMAGE_DLLCHARACTERISTICS_NX_COMPAT		 = 0x0100,	// Image is NX compatible
	IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 	 = 0x0200,	// Image understands isolation and doesn't want it
	IMAGE_DLLCHARACTERISTICS_NO_SEH		= 0x0400,		// Image does not use SEH.  No SE handler may reside in this image
	IMAGE_DLLCHARACTERISTICS_NO_BIND	= 0x0800,		// Do not bind this image.
//										  0x1000		// Reserved.
	IMAGE_DLLCHARACTERISTICS_WDM_DRIVER	= 0x2000,		// Driver uses WDM model
//										  0x4000		// Reserved.
	IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000
};

typedef struct {
	union {
		struct {
			WORD bIMAGE_LIBRARY_PROCESS_INIT : 1; 				// 0x0001     // Reserved.
			WORD bIMAGE_LIBRARY_PROCESS_TERM : 1; 				// 0x0002     // Reserved.
			WORD bIMAGE_LIBRARY_THREAD_INIT : 1;  				// 0x0004     // Reserved.
			WORD bIMAGE_LIBRARY_THREAD_TERM : 1;  				// 0x0008     // Reserved.
			WORD bReserved : 1;									// 0x0010	  // Reserved.
			WORD bReserved : 1;									// 0x0020	  // Reserved.
			WORD bIMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE : 1; 	// 0x0040     // DLL can move.
			WORD bIMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY : 1; // 0x0080     // Code Integrity Image
			WORD bIMAGE_DLLCHARACTERISTICS_NX_COMPAT : 1; 		// 0x0100     // Image is NX compatible
			WORD bIMAGE_DLLCHARACTERISTICS_NO_ISOLATION : 1; 	// 0x0200     // Image understands isolation and doesn't want it
			WORD bIMAGE_DLLCHARACTERISTICS_NO_SEH : 1; 			// 0x0400     // Image does not use SEH.  No SE handler may reside in this image
			WORD bIMAGE_DLLCHARACTERISTICS_NO_BIND : 1; 		// 0x0800     // Do not bind this image.
			WORD bReserved : 1; 								// 0x1000     // Reserved.
			WORD bIMAGE_DLLCHARACTERISTICS_WDM_DRIVER : 1; 		// 0x2000     // Driver uses WDM model
			WORD bReserved : 1; 								// 0x4000     // Reserved.
			WORD bIMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE : 1; // 0x8000			
		} BITMASK;
		WORD DllCharacteristics;
	} U;
}  IMAGE_OPTIONAL_DLLCHARACTERISTICS;

typedef struct {
	//
	// Standard fields.
	//
	WORD	Magic;
	BYTE	MajorLinkerVersion;
	BYTE	MinorLinkerVersion;
	DWORD   SizeOfCode;
	DWORD   SizeOfInitializedData;
	DWORD   SizeOfUninitializedData;
	DWORD   AddressOfEntryPoint;
	DWORD   BaseOfCode;
	DWORD   BaseOfData;

	//
	// NT additional fields.
	//
	DWORD   ImageBase;
	DWORD   SectionAlignment;
	DWORD   FileAlignment;
	WORD	MajorOperatingSystemVersion;
	WORD	MinorOperatingSystemVersion;
	WORD	MajorImageVersion;
	WORD	MinorImageVersion;
	WORD	MajorSubsystemVersion;
	WORD	MinorSubsystemVersion;
	DWORD   Win32VersionValue;
	DWORD   SizeOfImage;
	DWORD   SizeOfHeaders;
	DWORD   CheckSum;
	IMAGE_SUBSYSTEM	Subsystem;
	IMAGE_OPTIONAL_DLLCHARACTERISTICS	DllCharacteristics;
	DWORD   SizeOfStackReserve;
	DWORD   SizeOfStackCommit;
	DWORD   SizeOfHeapReserve;
	DWORD   SizeOfHeapCommit;
	DWORD   LoaderFlags;
	DWORD   NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32;

typedef struct {
	WORD		Magic;
	BYTE		MajorLinkerVersion;
	BYTE		MinorLinkerVersion;
	DWORD   	SizeOfCode;
	DWORD   	SizeOfInitializedData;
	DWORD   	SizeOfUninitializedData;
	DWORD   	AddressOfEntryPoint;
	DWORD   	BaseOfCode;
	uint64   	ImageBase;
	DWORD   	SectionAlignment;
	DWORD   	FileAlignment;
	WORD		MajorOperatingSystemVersion;
	WORD		MinorOperatingSystemVersion;
	WORD		MajorImageVersion;
	WORD		MinorImageVersion;
	WORD		MajorSubsystemVersion;
	WORD		MinorSubsystemVersion;
	DWORD   	Win32VersionValue;
	DWORD   	SizeOfImage;
	DWORD   	SizeOfHeaders;
	DWORD   	CheckSum;
	IMAGE_SUBSYSTEM	Subsystem;
	IMAGE_OPTIONAL_DLLCHARACTERISTICS		DllCharacteristics;
	uint64 	SizeOfStackReserve;
	uint64 	SizeOfStackCommit;
	uint64 	SizeOfHeapReserve;
	uint64 	SizeOfHeapCommit;
	DWORD   	LoaderFlags;
	DWORD   	NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64;

/*======================================== */

if (fileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER32) &&
	fileHeader.SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER64))
	Warning("Unknown IMAGE_OPTIONAL_HEADER size");

local WORD optMagic = ReadShort(FTell());
local int is64Bit = 0;

if (optMagic == 0x10b)
	IMAGE_OPTIONAL_HEADER32 optHeader <bgcolor=cLtGreen>;
else if (optMagic == 0x20b)
{
	IMAGE_OPTIONAL_HEADER64 optHeader <bgcolor=cLtGreen>;
	is64Bit = 1;
}
else
	Warning("Unknown optional header signature");

/*======================================== */

enum IMAGE_SECTION_CHARACTERISTICS_enum {
	IMAGE_SCN_TYPE_REG			= 0x00000000,	// Reserved.
	IMAGE_SCN_TYPE_DSECT		= 0x00000001,	// Reserved.
	IMAGE_SCN_TYPE_NOLOAD		= 0x00000002,	// Reserved.
	IMAGE_SCN_TYPE_GROUP		= 0x00000004,	// Reserved.
	IMAGE_SCN_TYPE_NO_PAD		= 0x00000008,	// Reserved.
	IMAGE_SCN_TYPE_COPY			= 0x00000010,	// Reserved.

	IMAGE_SCN_CNT_CODE			= 0x00000020,	// Section contains code.
	IMAGE_SCN_CNT_INITIALIZED_DATA	= 0x00000040,	// Section contains initialized data.
	IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080,	// Section contains uninitialized data.

	IMAGE_SCN_LNK_OTHER			= 0x00000100,	// Reserved.
	IMAGE_SCN_LNK_INFO			= 0x00000200,	// Section contains comments or some other type of information.
	IMAGE_SCN_TYPE_OVER			= 0x00000400,	// Reserved.
	IMAGE_SCN_LNK_REMOVE		= 0x00000800,	// Section contents will not become part of image.
	IMAGE_SCN_LNK_COMDAT		= 0x00001000,	// Section contents comdat.
//								= 0x00002000,	// Reserved.
//	IMAGE_SCN_MEM_PROTECTED - Obsolete	= 0x00004000
	IMAGE_SCN_NO_DEFER_SPEC_EXC	= 0x00004000,	// Reset speculative exceptions handling bits in the TLB entries for this section.
	IMAGE_SCN_GPREL				= 0x00008000,	// Section content can be accessed relative to GP
	IMAGE_SCN_MEM_FARDATA		= 0x00008000,
	IMAGE_SCN_MEM_SYSHEAP		= 0x00010000,
	IMAGE_SCN_MEM_PURGEABLE		= 0x00020000,
	IMAGE_SCN_MEM_16BIT			= 0x00020000,
	IMAGE_SCN_MEM_LOCKED		= 0x00040000,
	IMAGE_SCN_MEM_PRELOAD		= 0x00080000,

	IMAGE_SCN_ALIGN_1BYTES		= 0x00100000,	//
	IMAGE_SCN_ALIGN_2BYTES		= 0x00200000,	//
	IMAGE_SCN_ALIGN_4BYTES		= 0x00300000,	//
	IMAGE_SCN_ALIGN_8BYTES		= 0x00400000,	//
	IMAGE_SCN_ALIGN_16BYTES		= 0x00500000,	// Default alignment if no others are specified.
	IMAGE_SCN_ALIGN_32BYTES		= 0x00600000,	//
	IMAGE_SCN_ALIGN_64BYTES		= 0x00700000,	//
	IMAGE_SCN_ALIGN_128BYTES	= 0x00800000,	//
	IMAGE_SCN_ALIGN_256BYTES	= 0x00900000,	//
	IMAGE_SCN_ALIGN_512BYTES	= 0x00A00000,	//
	IMAGE_SCN_ALIGN_1024BYTES	= 0x00B00000,	//
	IMAGE_SCN_ALIGN_2048BYTES	= 0x00C00000,	//
	IMAGE_SCN_ALIGN_4096BYTES	= 0x00D00000,	//
	IMAGE_SCN_ALIGN_8192BYTES	= 0x00E00000,	//
//						Unused	= 0x00F00000
	IMAGE_SCN_ALIGN_MASK		= 0x00F00000,

	IMAGE_SCN_LNK_NRELOC_OVFL	= 0x01000000,	// Section contains extended relocations.
	IMAGE_SCN_MEM_DISCARDABLE	= 0x02000000,	// Section can be discarded.
	IMAGE_SCN_MEM_NOT_CACHED	= 0x04000000,	// Section is not cachable.
	IMAGE_SCN_MEM_NOT_PAGED		= 0x08000000,	// Section is not pageable.
	IMAGE_SCN_MEM_SHARED		= 0x10000000,	// Section is shareable.
	IMAGE_SCN_MEM_EXECUTE		= 0x20000000,	// Section is executable.
	IMAGE_SCN_MEM_READ			= 0x40000000,	// Section is readable.
	IMAGE_SCN_MEM_WRITE			= 0x80000000,	// Section is writeable.

	IMAGE_SCN_SCALE_INDEX	= 0x00000001	// Tls index is scaled
};

typedef struct {
	union {
		struct {
			DWORD bIMAGE_SCN_TYPE_DSECT : 1;	// 0x00000001,	// Reserved.
			DWORD bIMAGE_SCN_TYPE_NOLOAD : 1;	// 0x00000002,	// Reserved.
			DWORD bIMAGE_SCN_TYPE_GROUP : 1;	// 0x00000004,	// Reserved.
			DWORD bIMAGE_SCN_TYPE_NO_PAD : 1;	// 0x00000008,	// Reserved.
			DWORD bIMAGE_SCN_TYPE_COPY : 1;		// 0x00000010,	// Reserved.

			DWORD bIMAGE_SCN_CNT_CODE : 1;					// 0x00000020,	// Section contains code.
			DWORD bIMAGE_SCN_CNT_INITIALIZED_DATA : 1;		// 0x00000040,	// Section contains initialized data.
			DWORD bIMAGE_SCN_CNT_UNINITIALIZED_DATA : 1;	//0x00000080,	// Section contains uninitialized data.

			DWORD bIMAGE_SCN_LNK_OTHER : 1;		// 0x00000100,	// Reserved.
			DWORD bIMAGE_SCN_LNK_INFO : 1;		// 0x00000200,	// Section contains comments or some other type of information.
			DWORD bIMAGE_SCN_TYPE_OVER : 1;		// 0x00000400,	// Reserved.
			DWORD bIMAGE_SCN_LNK_REMOVE : 1;	// 0x00000800,	// Section contents will not become part of image.
			DWORD bIMAGE_SCN_LNK_COMDAT : 1;	// 0x00001000,	// Section contents comdat.
			DWORD bUnused : 1;					// 0x00002000,	// Reserved.
			DWORD bIMAGE_SCN_NO_DEFER_SPEC_EXC : 1;	// 0x00004000,	// Reset speculative exceptions handling bits in the TLB entries for this section.
			DWORD bIMAGE_SCN_GPREL : 1;			// 0x00008000,	// Section content can be accessed relative to GP
			DWORD bIMAGE_SCN_MEM_SYSHEAP : 1;	// 0x00010000
			DWORD bIMAGE_SCN_MEM_PURGEABLE : 1;	// 0x00020000
			DWORD bIMAGE_SCN_MEM_LOCKED : 1;	// 0x00040000
			DWORD bIMAGE_SCN_MEM_PRELOAD : 1;	// 0x00080000

			DWORD bIMAGE_SCN_ALIGN_BITS : 4;

			DWORD bIMAGE_SCN_LNK_NRELOC_OVFL : 1;	// 0x01000000,	// Section contains extended relocations.
			DWORD bIMAGE_SCN_MEM_DISCARDABLE : 1;	// 0x02000000,	// Section can be discarded.
			DWORD bIMAGE_SCN_MEM_NOT_CACHED : 1;	// 0x04000000,	// Section is not cachable.
			DWORD bIMAGE_SCN_MEM_NOT_PAGED : 1;		// 0x08000000,	// Section is not pageable.
			DWORD bIMAGE_SCN_MEM_SHARED : 1;		// 0x10000000,	// Section is shareable.
			DWORD bIMAGE_SCN_MEM_EXECUTE : 1;		// 0x20000000,	// Section is executable.
			DWORD bIMAGE_SCN_MEM_READ : 1;			// 0x40000000,	// Section is readable.
			DWORD bIMAGE_SCN_MEM_WRITE : 1;			// 0x80000000,	// Section is writeable.
		} BITMASK;
		DWORD Characteristics;
	} U;
} IMAGE_SECTION_CHARACTERISTICS;

typedef struct {
	BYTE	Name[8];
	union {
			DWORD   PhysicalAddress;
			DWORD   VirtualSize;
	} Misc;
	DWORD   VirtualAddress;
	DWORD   SizeOfRawData;
	DWORD   PointerToRawData;
	DWORD   PointerToRelocations;
	DWORD   PointerToLinenumbers;
	WORD	NumberOfRelocations;
	WORD	NumberOfLinenumbers;
	IMAGE_SECTION_CHARACTERISTICS Characteristics;
} IMAGE_SECTION_HEADER <read=ReadSectHeader>;

string ReadSectHeader(IMAGE_SECTION_HEADER &h)
{
	if (exists(h.Name))
		return (h.Name);
	else
		return ("");
}

/*======================================== */
IMAGE_SECTION_HEADER sectionHeaders[fileHeader.NumberOfSections] <bgcolor=cLtPurple>;
/*======================================== */

int
GetSectForRva(int rva)
{
	local int ret = -1;
	local int i=0;
	local int sectBeginVa, sectEndVa;

	for (i = 0; i < fileHeader.NumberOfSections; ++i)
	{
		sectBeginVa = sectionHeaders[i].VirtualAddress;
		sectEndVa = sectBeginVa + sectionHeaders[i].SizeOfRawData;
		
		if (rva >= sectBeginVa && rva <= sectEndVa)
		{
			ret = i;
			break;
		}
	}
	return (ret);
}

int
GetSectOffsetForRva(int rva)
{
	return (rva - sectionHeaders[GetSectForRva(rva)].VirtualAddress);
}

int
GetFileOffsetForRva(int rva)
{
	return (sectionHeaders[GetSectForRva(rva)].PointerToRawData +
			GetSectOffsetForRva(rva));
}

typedef enum {
	IMAGE_DIRECTORY_ENTRY_EXPORT 		= 0,
	IMAGE_DIRECTORY_ENTRY_IMPORT 		= 1,   	// Import Directory
	IMAGE_DIRECTORY_ENTRY_RESOURCE  	= 2,   	// Resource Directory
	IMAGE_DIRECTORY_ENTRY_EXCEPTION		= 3 ,  	// Exception Directory
	IMAGE_DIRECTORY_ENTRY_SECURITY   	= 4 ,  	// Security Directory
	IMAGE_DIRECTORY_ENTRY_BASERELOC  	= 5 ,  	// Base Relocation Table
	IMAGE_DIRECTORY_ENTRY_DEBUG  		= 6 , 	// Debug Directory
//  IMAGE_DIRECTORY_ENTRY_COPYRIGHT   	7 		// (X86 usage)
	IMAGE_DIRECTORY_ENTRY_ARCHITECTURE	= 7,	// Architecture Specific Data
	IMAGE_DIRECTORY_ENTRY_GLOBALPTR   	= 8,	// RVA of GP
	IMAGE_DIRECTORY_ENTRY_TLS			= 9,	// TLS Directory
	IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG  	= 10,	// Load Configuration Directory
	IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 	= 11,	// Bound Import Directory in headers
	IMAGE_DIRECTORY_ENTRY_IAT 			= 12,	// Import Address Table
	IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 	= 13,	// Delay Load Import Descriptors
	IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14	// COM Runtime descriptor
} DIRINDS;

// IMAGE_DIRECTORY_ENTRY_EXPORT
typedef struct {
    DWORD   Characteristics;
    time_t   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY <read=GetExportDirName>;

string
GetExportDirName(IMAGE_EXPORT_DIRECTORY &ed)
{
	local int si = GetSectForRva(ed.Name);

	if (si == -1)
		return ("(error)");

	return (ReadString(GetFileOffsetForRva(ed.Name)));
}

typedef struct {
	DWORD rva;
} EXPORT_NAME <read=GetExportName>;

string
GetExportName(EXPORT_NAME &en)
{
	return (ReadString(GetFileOffsetForRva(en.rva)));
}

void
ReadExportDirectory()
{
/*======================================== */
	struct {
		IMAGE_EXPORT_DIRECTORY exportDirectory;
		
		FSeek(GetFileOffsetForRva(exportDirectory.AddressOfFunctions));
		DWORD functionAddres[exportDirectory.NumberOfFunctions];
		FSeek(GetFileOffsetForRva(exportDirectory.AddressOfNameOrdinals));
		WORD functionRelOrdinals[exportDirectory.NumberOfFunctions];
		FSeek(GetFileOffsetForRva(exportDirectory.AddressOfNames));
		EXPORT_NAME functionNames[exportDirectory.NumberOfNames];
	} Exports;
/*======================================== */
}

// IMAGE_DIRECTORY_ENTRY_IMPORT
typedef struct {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } U;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)
    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR <read=GetImportName>;

string
GetImportName(IMAGE_IMPORT_DESCRIPTOR &di)
{
	if (di.Name == 0)
		return ("(null)");

	local int64 nameOff = GetFileOffsetForRva(di.Name);

	if (nameOff < 0 || nameOff > FileSize())
		return ("(error)");
	return (ReadString(nameOff));
}

typedef struct {
	WORD Hint;
	string Name;
} IMAGE_IMPORT_BY_NAME <read=GetImportByName>;

string
GetImportByName(IMAGE_IMPORT_BY_NAME &i)
{
	return (i.Name);
}

typedef struct {
	union {
		struct {
			union {
				struct {
					DWORD Ordinal : 16;
					DWORD Unused : 15;
				} S1;
				DWORD NameRva : 31;
			} U1;
			DWORD ImportByOrdinal : 1;
		} S;
		DWORD value;
	} U;
} IMPORT_THUNK32 <read=GetThunk32Name>;

string
GetThunk32Name(IMPORT_THUNK32 &t)
{
	if (t.U.value == 0)
		return ("(null)");

	if (t.U.S.ImportByOrdinal == 1)
	{
		string r;
		SPrintf(r, "#%d", t.U.S.U1.S1.Ordinal);
		return (r);
	}

	if (GetSectForRva(t.U.S.U1.NameRva) != -1)
	{
		return (ReadString(GetFileOffsetForRva(t.U.S.U1.NameRva)+sizeof(WORD)));
	}
	
	string r;
	SPrintf(r, "0x%p", t.U.value);
	return (r);
}

typedef struct {
	union {
		struct {
			union {
				struct {
					QWORD Ordinal : 32;
					QWORD Unused : 31;
				} S1;
				QWORD NameRva : 63;
			} U1;
			QWORD ImportByOrdinal : 1;
		} S;
		QWORD value;
	} U;
} IMPORT_THUNK64 <read=GetThunk64Name>;

string
GetThunk64Name(IMPORT_THUNK64 &t)
{
	if (t.U.value == 0)
		return ("(null)");

	if (t.U.S.ImportByOrdinal == 1)
	{
		string r;
		return (r);
	}

	if (GetSectForRva(t.U.S.U1.NameRva) != -1)
	{
		return (ReadString(GetFileOffsetForRva(t.U.S.U1.NameRva)+sizeof(WORD)));
	}
	
	string r;
	return (r);
}

typedef struct {
	IMAGE_IMPORT_DESCRIPTOR importDesc;
	local int64 _pos = FTell();
	local int64 __pos = -1;

	if (importDesc.U.OriginalFirstThunk != 0)
	{
		FSeek(GetFileOffsetForRva(importDesc.U.OriginalFirstThunk));
		
		struct {
			do {
				if (!is64Bit)
					IMPORT_THUNK32 thunk;
				else
					IMPORT_THUNK64 thunk;

				if (thunk.U.value != 0 && thunk.U.S.ImportByOrdinal != 1 &&
					GetSectForRva(thunk.U.S.U1.NameRva) != -1)
				{
					__pos = FTell();
					FSeek(GetFileOffsetForRva(thunk.U.S.U1.NameRva));
					IMAGE_IMPORT_BY_NAME name;
					FSeek(__pos);
				}
			} while (thunk.U.value != 0);
		} OriginalFirstThunks;
	}

	if (importDesc.FirstThunk != 0)
	{
		FSeek(GetFileOffsetForRva(importDesc.FirstThunk));
		struct {
			do {
				if (!is64Bit)
					IMPORT_THUNK32 thunk;
				else
					IMPORT_THUNK64 thunk;
			} while (thunk.U.value != 0);
		} FirstThunks;
	}
	FSeek(_pos);
} IMPORT_DLL <read=GetImportDllName>;
	
string
GetImportDllName(IMPORT_DLL &id)
{
	return (GetImportName(id.importDesc));
}

void
ReadImportDirectory()
{
/*======================================== */
	struct {
		do {
			IMPORT_DLL import;
		} while (import.importDesc.Name != 0);
	} Imports <bgcolor=cLtRed>;
/*======================================== */
}

// IMAGE_DIRECTORY_ENTRY_RESOURCE
typedef struct  {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY;

typedef struct  {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } S;
        DWORD   Name;
        WORD    Id;
    } U;
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        } S1;
    } U1;
} IMAGE_RESOURCE_DIRECTORY_ENTRY <read=GetRsrcDirEntName>;

string
GetRsrcDirEntName(IMAGE_RESOURCE_DIRECTORY_ENTRY &e)
{
	if (e.U.S.NameIsString == 1)
	{
		local int nameOff = rsrcDirFOff + e.U.S.NameOffset;
		local int nameLen = ReadUShort(nameOff);
		wchar_t str[nameLen];
		ReadWStr(nameOff + sizeof(ushort), str, nameLen);
		return (str);
	}

/* Only in root...
	switch (e.U.Id)
	{
	case 1:
		return ("(cursor)");
	case 2:
		return ("(bitmap)");
	case 3:
		return ("(icon)");
	case 4:
		return ("(menu)");
	case 5:
		return ("(dialog)");
	case 6:
		return ("(string table)");
	case 7:
		return ("(font directory)");
	case 8:
		return ("(font)");
	case 9:
		return ("(accelerators)");
	case 10:
		return ("(unformatted)");
	case 11:
		return ("(message table)");
	case 12:
		return ("(group cursor)");
	case 14:
		return ("(group icon)");
	case 16:
		return ("(version information)");
	}
*/

	string r = "";
	SPrintf(r, "#%d", e.U.Id);
	return (r);
}

typedef struct {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY;

void
ReadResourceDataEntry()
{
/*======================================== */
	struct {
		IMAGE_RESOURCE_DATA_ENTRY DataEntry;
		local int64 _pos = FTell();
		FSeek(GetFileOffsetForRva(DataEntry.OffsetToData));
		BYTE Data[DataEntry.Size];
		FSeek(_pos);
	} DataEntry;
/*======================================== */
}			

void
ReadResourceDirectory()
{
/*======================================== */
	struct {
		IMAGE_RESOURCE_DIRECTORY rsrcDir;
	
		local int i=0;
		local int64 _pos = -1;
		for (i = 0; i < rsrcDir.NumberOfNamedEntries; ++i)
		{
			struct {
				IMAGE_RESOURCE_DIRECTORY_ENTRY namedEnt;

				if (namedEnt.U1.S1.DataIsDirectory == 1)
				{
					_pos = FTell();
					FSeek(rsrcDirFOff + namedEnt.U1.S1.OffsetToDirectory);
					ReadResourceDirectory();
					FSeek(_pos);
				}
				else
				{
					_pos = FTell();
					FSeek(rsrcDirFOff + namedEnt.U1.OffsetToData);
					ReadResourceDataEntry();
					FSeek(_pos);
				}		
			} NamedEntry;
		}
	
		for (i = 0; i < rsrcDir.NumberOfIdEntries; ++i)
		{
			struct {
				IMAGE_RESOURCE_DIRECTORY_ENTRY idEnt;
	
				if (idEnt.U1.S1.DataIsDirectory == 1)
				{
					_pos = FTell();
					FSeek(rsrcDirFOff + idEnt.U1.S1.OffsetToDirectory);
					ReadResourceDirectory();
					FSeek(_pos);
				}
				else
				{
					_pos = FTell();
					FSeek(rsrcDirFOff + idEnt.U1.OffsetToData);
					ReadResourceDataEntry();
					FSeek(_pos);
				}	
			} IdEntry;
		}
	} RsrcDir;
/*======================================== */
}	

local int64 rsrcDirFOff = -1;

void
ReadResourceDataDirectory()
{
/*======================================== */
	rsrcDirFOff = FTell();
	struct {
		ReadResourceDirectory();
	} Resources <bgcolor=cLtAqua>;
/*======================================== */
}

// IMAGE_DIRECTORY_ENTRY_EXCEPTION

// IMAGE_DIRECTORY_ENTRY_SECURITY

// IMAGE_DIRECTORY_ENTRY_BASERELOC
typedef struct {
	DWORD   VirtualAddress;
	DWORD   SizeOfBlock;
//	WORD	TypeOffset[SizeOfBlock / sizeof(WORD)];
} IMAGE_BASE_RELOCATION;

typedef struct {
	WORD Offset : 12;
	WORD Type : 4;
} RELOC;

struct IMAGE_RELOCATION {
	union {
		DWORD   VirtualAddress;
		DWORD   RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
	} DUMMYUNIONNAME;
	DWORD   SymbolTableIndex;
	WORD	Type;
};

void
ReadBaseRelocDirectory()
{
/*======================================== */
	struct {
		local int relocSpace = optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

		do {
			struct {
				IMAGE_BASE_RELOCATION imageBaseReloc;
				RELOC relocs[(imageBaseReloc.SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD)];
			} Reloc;
			relocSpace -= sizeof(Reloc);
		} while (relocSpace >= sizeof(IMAGE_BASE_RELOCATION));
	} BaseRelocs <bgcolor=cSilver>;
/*======================================== */
}

// IMAGE_DIRECTORY_ENTRY_DEBUG
typedef enum {
	IMAGE_DEBUG_TYPE_UNKNOWN		= 0,
	IMAGE_DEBUG_TYPE_COFF			= 1,
	IMAGE_DEBUG_TYPE_CODEVIEW		= 2,
	IMAGE_DEBUG_TYPE_FPO			= 3,
	IMAGE_DEBUG_TYPE_MISC			= 4,
	IMAGE_DEBUG_TYPE_EXCEPTION		= 5,
	IMAGE_DEBUG_TYPE_FIXUP			= 6,
	IMAGE_DEBUG_TYPE_OMAP_TO_SRC	= 7,
	IMAGE_DEBUG_TYPE_OMAP_FROM_SRC	= 8,
	IMAGE_DEBUG_TYPE_BORLAND		= 9,
	IMAGE_DEBUG_TYPE_RESERVED10		= 10,
	IMAGE_DEBUG_TYPE_CLSID			= 11
} IMAGE_DEBUG_TYPE;

typedef struct {
	DWORD data1;
	WORD data2;
	WORD data3;
	WORD data3b;
	unsigned byte data4[6];
} GUID <read=GetGuidString>;

string
GetGuidString(GUID &g)
{
	char buf[38];

	SPrintf(buf, "{%x-%x-%x-%x-%x%x%x%x%x%x}", g.data1, g.data2, g.data3, g.data3b,
		g.data4[0], g.data4[1], g.data4[2], g.data4[3], g.data4[4], g.data4[5]);
	
	return (buf);
}

void
ReadDebugDataDirectory()
{
/*======================================== */
	struct {
		local int preoff = FTell();
		DWORD	Characteristics;
		time_t	TimeDateStamp;
		WORD	MajorVersion;
		WORD	MinorVersion;
		IMAGE_DEBUG_TYPE Type;
		DWORD	SizeOfData;
		DWORD	AddressOfRawData;
		DWORD	PointerToRawData;

		if (Type == IMAGE_DEBUG_TYPE_CODEVIEW)
		{
			if (PointerToRawData + SizeOfData > FileSize())
				Warning("DebugInfo Overflow");

			FSeek(PointerToRawData);

			struct {
				char debugSig[4];

				//if (debugSig != "RSDS")
				//	Warning("Not PDB 7.0 CodeView");
				if (debugSig == "RSDS")
				{			
					GUID Guid<read=GetGuidString>;
					DWORD Age;
					string PdbFileName;
				} 
				else if (debugSig == "NB10")
				{
					LONG offset;
					time_t TimeDateStamp;
					DWORD Age;
					string PdbFileName;
				}
			} CodeView;
		}
		FSeek(preoff+1);
	} DebugInfo;
/*======================================== */
}
// IMAGE_DIRECTORY_ENTRY_ARCHITECTURE
// IMAGE_DIRECTORY_ENTRY_GLOBALPTR
// IMAGE_DIRECTORY_ENTRY_TLS
// IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG
// IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT
// IMAGE_DIRECTORY_ENTRY_IAT
// IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT
// IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR

typedef enum <DWORD> {
    COMIMAGE_FLAGS_IONLY            = 0x1,
    COMIMAGE_FLAGS_32BITREQUIRED    = 0x2,
    COMIMAGE_FLAGS_IL_LIBRARY       = 0x4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x10,
    COMIMAGE_FLAGS_TRACKDEBUGDATA   = 0x10000
} CORHDRFLAGS;

typedef struct {
    DWORD       cb;
    WORD        MajorRuntimeVersion;
    WORD        MinorRuntimeVersion;
    IMAGE_DATA_DIRECTORY MetaData;
    CORHDRFLAGS Flags;
    
    union {
        DWORD EntryPointToken;
        DWORD EntryPointRVA;
    } EntryPoint;
    
    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
    IMAGE_DATA_DIRECTORY ManagedNativeHeader;
} IMAGE_COR20_HEADER;

typedef struct {
    DWORD offset;
    DWORD Size;
    char Name[];

    if (sizeof(Name) % 4 != 0)
        char padding[4 - (sizeof(Name) % 4)];
} IMAGE_CLR_STREAMHEADER <read=ReadClrStreamHeader>;

string
ReadClrStreamHeader(IMAGE_CLR_STREAMHEADER &h)
{
    if (exists(h.Name))
        return (h.Name);
    else
        return ("");
}

typedef struct {
    char signature[4];
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Reserved;
    DWORD Length;
    char version[Length];
    
    if (sizeof(version) % 4 != 0)
        char padding[4 - (sizeof(version) % 4)];

    WORD Flags;
    WORD cbStreams;
    
    IMAGE_CLR_STREAMHEADER streams[cbStreams] <optimize=false>;
} IMAGE_CLR_METADATA;

typedef struct {
    char clrString[];
} CLRSTRING <read=ReadClrString>;

string
ReadClrString(CLRSTRING &h)
{
    if (exists(h.clrString))
        return h.clrString;
    else
        return "";
}

typedef struct {
    UBYTE cb;
    if (cb != 0)
    {
        if ((cb & 0x80) == 0)
        {
            wchar_t clrWString[cb/2];
            BYTE null;
        } else if ((cb & 0x80) == 0x80) {
            UBYTE cb2;
            local unsigned short cc = cb & 0x7f;
            local unsigned short len = cc * 256 + cb2;
            wchar_t clrWString[len/2];
            BYTE null;
        } else if ((cb & 0xC0) == 0xC0) {
            UBYTE cb2;
            USHORT cw;
            local ULONG len = (cb & 0x3F) << 24 + cb2 << 16 + cw4;
            wchar_t clrWString[len/2];
            BYTE null;
        }
    }
} CLRWSTRING <read=ReadClrWString>;

string
ReadClrWString(CLRWSTRING &h)
{
    if (exists(h.clrWString))
        return h.clrWString;
    else
        return "";
}

typedef struct {
    union {
        struct {
  /* 0x00 */INT64 bModule : 1;
  /* 0x01 */INT64 bTypeRef : 1;
  /* 0x02 */INT64 bTypeDef : 1;
  /* 0x03 */INT64 bReserved1 : 1;
  /* 0x04 */INT64 bField : 1;
  /* 0x05 */INT64 bReserved2 : 1;
  /* 0x06 */INT64 bMethodDef : 1;
  /* 0x07 */INT64 bReserved3 : 1;
  /* 0x08 */INT64 bParam : 1;
  /* 0x09 */INT64 bInterfaceImpl : 1;
  /* 0x0A */INT64 bMemberRef : 1;
  /* 0x0B */INT64 bConstant : 1;
  /* 0x0C */INT64 bCustomAttribute : 1;
  /* 0x0D */INT64 bFieldMarshal : 1;
  /* 0x0E */INT64 bDeclSecurity : 1;
  /* 0x0F */INT64 bClassLayout : 1;
  /* 0x10 */INT64 bFieldLayout : 1;
  /* 0x11 */INT64 bStandAloneSig : 1;
  /* 0x12 */INT64 bEventMap : 1;
  /* 0x13 */INT64 bReserved4 : 1;
  /* 0x14 */INT64 bEvent : 1;
  /* 0x15 */INT64 bPropertyMap : 1;
  /* 0x16 */INT64 bReserved5 : 1;
  /* 0x17 */INT64 bProperty : 1;
  /* 0x18 */INT64 bMethodSemantics : 1;
  /* 0x19 */INT64 bMethodImpl : 1;
  /* 0x1A */INT64 bModuleRef : 1;
  /* 0x1B */INT64 bTypeSpec : 1;
  /* 0x1C */INT64 bImplMap : 1;
  /* 0x1D */INT64 bFieldRVA : 1;
  /* 0x1E */INT64 bReserved6 : 1;
  /* 0x1F */INT64 bReserved7 : 1;
  /* 0x20 */INT64 bAssembly : 1;
  /* 0x21 */INT64 bAssemblyProcessor : 1;
  /* 0x22 */INT64 bAssemblyOS : 1;
  /* 0x23 */INT64 bAssemblyRef : 1;
  /* 0x24 */INT64 bAssemblyRefProcessor : 1;
  /* 0x25 */INT64 bAssemblyRefOS : 1;
  /* 0x26 */INT64 bFile : 1;
  /* 0x27 */INT64 bExportedType : 1;
  /* 0x28 */INT64 bManifestResource : 1;
  /* 0x29 */INT64 bNestedClass : 1;
  /* 0x2A */INT64 bGenericParam : 1;
  /* 0x2B */INT64 bMethodSpec : 1;
  /* 0x2C */INT64 bGenericParamConstraint : 1;
            INT64 bReserved8 : 18;
        } BITMASK;
        INT64 ValidTables;
    } U;
} IMAGE_DOTNET_TABLEMASK;

typedef struct {
    DWORD reserved;
    BYTE MajorVersion;
    BYTE MinorVersion;
    BYTE HeapSizes;
    BYTE Reserved;
    IMAGE_DOTNET_TABLEMASK Valid;
    IMAGE_DOTNET_TABLEMASK Sorted;
    int Rows[getNumSetBits(Valid.U.ValidTables)];
} CHASHSWISH;

int
getNumSetBits(INT64 n)
{
    local int count = 0;
    while (n)
    {
        n &= n-1;
        count++;
    }
    return (count);
}

void
ReadCLRDataDirectory()
{
    struct {
        IMAGE_COR20_HEADER clrHeader;

        local int metadataOffset = GetFileOffsetForRva(clrHeader.MetaData.VirtualAddress);
        FSeek(metadataOffset);
        IMAGE_CLR_METADATA clrMetadata;

        local int i;
        for (i=0; i < clrMetadata.cbStreams; ++i)
        {
            switch (clrMetadata.streams[i].Name)
            {
            case "#~":
                if (clrMetadata.streams[i].offset <= 0 || clrMetadata.streams[i].offset > FileSize())
                    Warning("Illegal IMAGE_CLR_STREAMHEADER offset");
                else {
                    FSeek(clrMetadata.streams[i].offset + metadataOffset);
                    CHASHSWISH cHashSwish;
                    struct {
                        BYTE bytes[clrMetadata.streams[i].Size - sizeof(cHashSwish)];
                    } ToDoHashSwish <bgcolor=cLtRed>;
                }
                break;
            case "#Strings":
                if (clrMetadata.streams[i].offset <= 0 || clrMetadata.streams[i].offset > FileSize())
                    Warning("Illegal IMAGE_CLR_STREAMHEADER offset");
                else {
                    FSeek(clrMetadata.streams[i].offset + metadataOffset);
                    struct {
                        do {                       
                            CLRSTRING s;
                        } while (FTell() <= (metadataOffset + clrMetadata.streams[i].offset + clrMetadata.streams[i].Size));
                    } identifierStrings <bgcolor=cLtGreen>;
                }                   
                break;
            case "#US":
                if (clrMetadata.streams[i].offset <= 0 || clrMetadata.streams[i].offset > FileSize())
                    Warning("Illegal IMAGE_CLR_STREAMHEADER offset");
                else {
                    FSeek(clrMetadata.streams[i].offset + metadataOffset);
                    struct {
                        do {                       
                            CLRWSTRING s;
                        } while (FTell() < (metadataOffset + clrMetadata.streams[i].offset + clrMetadata.streams[i].Size));
                    } userStrings <bgcolor=cLtAqua>;
                }  
                break;
            case "#GUID":
                if (clrMetadata.streams[i].offset <= 0 || clrMetadata.streams[i].offset > FileSize())
                    Warning("Illegal IMAGE_CLR_STREAMHEADER offset");
                else {
                    FSeek(clrMetadata.streams[i].offset + metadataOffset);
                    GUID guids[clrMetadata.streams[i].Size / 16] <bgcolor=cSilver>;
                }
                break;
            case "#Blob":
                if (clrMetadata.streams[i].offset <= 0 || clrMetadata.streams[i].offset > FileSize())
                    Warning("Illegal IMAGE_CLR_STREAMHEADER offset");
                else {
                    FSeek(clrMetadata.streams[i].offset + metadataOffset);
                    struct {
                        BYTE bytes[clrMetadata.streams[i].Size];
                    } ToDoBlob <bgcolor=cLtRed>;
                }
                break;
            }
        }
    } ClrData;
}
/*======================================== */

local int ddi;
local int si;
local int ddRva, ddSize;
local int sectRva, sectSize, sectFileOffset;
local int64 sectOffset;

for (ddi = 0; ddi < optHeader.NumberOfRvaAndSizes; ++ddi)
{
	ddRva = optHeader.DataDirectory[ddi].VirtualAddress;
	ddSize = optHeader.DataDirectory[ddi].Size;

	if (ddRva != 0 || ddSize != 0)
	{
		if ((ddRva == 0 && ddSize != 0) || (ddRva != 0 && ddSize == 0))
			Warning("Data directory RVA/Size inconsistency");
	
		si = GetSectForRva(ddRva);

		if (si >= 0)
		{
			sectRva = sectionHeaders[si].VirtualAddress;
			sectSize = sectionHeaders[si].SizeOfRawData;
			sectFileOffset = sectionHeaders[si].PointerToRawData;
			
			if ((ddRva + ddSize) > (sectRva + sectSize))
				Warning("DD overflow");
	
			sectOffset = ddRva - sectRva;
	
			if (sectFileOffset + sectOffset > sectRva + sectSize ||
				sectFileOffset + sectOffset > FileSize())
				Warning("SectFileOffset calc error");
	
			FSeek(GetFileOffsetForRva(ddRva));
	
			switch (ddi)
			{
			case IMAGE_DIRECTORY_ENTRY_EXPORT:
				ReadExportDirectory();
				break;
			case IMAGE_DIRECTORY_ENTRY_IMPORT:
				ReadImportDirectory();
				break;
			case IMAGE_DIRECTORY_ENTRY_RESOURCE:
				ReadResourceDataDirectory();
				break;
// IMAGE_DIRECTORY_ENTRY_EXCEPTION

// IMAGE_DIRECTORY_ENTRY_SECURITY
			case IMAGE_DIRECTORY_ENTRY_BASERELOC:
				ReadBaseRelocDirectory();
				break;
			case IMAGE_DIRECTORY_ENTRY_DEBUG:
				ReadDebugDataDirectory();
				break;
            case IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR:
                ReadCLRDataDirectory();
                break;
			}
		} else
			Warning("ddi=%d ddRva=0x%p: si < 0", ddi, ddRva);
	} // if (ddRva != 0 || ddSize != 0)	
} // for (ddi = 0; ddi < optHeader.NumberOfRvaAndSizes; ++ddi)
